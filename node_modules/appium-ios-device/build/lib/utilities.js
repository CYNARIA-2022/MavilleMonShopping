"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectPort = connectPort;
exports.connectPortSSL = connectPortSSL;
exports.fetchImageFromGithubRepo = fetchImageFromGithubRepo;
exports.getConnectedDevices = getConnectedDevices;
exports.getDeviceInfo = getDeviceInfo;
exports.getDeviceName = getDeviceName;
exports.getDeviceTime = getDeviceTime;
exports.getOSVersion = getOSVersion;
exports.startLockdownSession = startLockdownSession;
require("source-map-support/register");
var _usbmux = _interopRequireWildcard(require("./usbmux"));
var _sslHelper = require("./ssl-helper");
var _lodash = _interopRequireDefault(require("lodash"));
var _logger = _interopRequireDefault(require("./logger"));
var _list_developer_image = require("./imagemounter/utils/list_developer_image");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const LOCKDOWN_REQUEST = {
  DEVICE_TIME: {
    Key: 'TimeIntervalSince1970'
  },
  DEVICE_UTC_OFFSET: {
    Key: 'TimeZoneOffsetFromUTC'
  },
  DEVICE_TIME_ZONE: {
    Key: 'TimeZone'
  },
  DEVICE_VERSION: {
    Key: 'ProductVersion'
  },
  DEVICE_NAME: {
    Key: 'DeviceName'
  }
};
async function getConnectedDevices(socket = null) {
  let usbmux;
  try {
    usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));
  } catch (e) {
    _logger.default.debug(e);
    return [];
  }
  try {
    const devices = await usbmux.listDevices();
    const udids = devices.map(device => device.Properties.SerialNumber);
    return _lodash.default.uniq(udids);
  } finally {
    usbmux.close();
  }
}
async function getOSVersion(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));
  try {
    const lockdown = await usbmux.connectLockdown(udid);
    return await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_VERSION);
  } finally {
    usbmux.close();
  }
}
async function getDeviceName(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));
  try {
    const lockdown = await usbmux.connectLockdown(udid);
    return await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_NAME);
  } finally {
    usbmux.close();
  }
}
async function getDeviceInfo(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));
  try {
    const lockdown = await usbmux.connectLockdown(udid);
    return await lockdown.getValue();
  } finally {
    usbmux.close();
  }
}
async function getDeviceTime(udid, socket = null) {
  const lockdown = await startLockdownSession(udid, socket);
  try {
    return {
      timestamp: await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_TIME),
      utcOffset: (await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_UTC_OFFSET)) / 60,
      timeZone: await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_TIME_ZONE)
    };
  } finally {
    lockdown.close();
  }
}
async function startLockdownSession(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));
  try {
    const pairRecord = await usbmux.readPairRecord(udid);
    if (!pairRecord) {
      throw new Error(`Could not find a pair record for device '${udid}'. Please first pair with the device`);
    }
    const lockdown = await usbmux.connectLockdown(udid);
    await lockdown.startSession(pairRecord.HostID, pairRecord.SystemBUID);
    lockdown.enableSessionSSL(pairRecord.HostPrivateKey, pairRecord.HostCertificate);
    return lockdown;
  } catch (e) {
    usbmux.close();
    throw e;
  }
}
async function connectPortSSL(udid, port, socket = null, handshakeOnly = false) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));
  try {
    const device = await usbmux.findDevice(udid);
    if (!device) {
      throw new Error(`Could not find the expected device '${udid}'`);
    }
    const pairRecord = await usbmux.readPairRecord(udid);
    if (!pairRecord) {
      throw new Error(`Could not find a pair record for device '${udid}'. Please first pair with the device`);
    }
    const socket = await usbmux.connect(device.Properties.DeviceID, port, undefined);
    return handshakeOnly ? await (0, _sslHelper.enableSSLHandshakeOnly)(socket, pairRecord.HostPrivateKey, pairRecord.HostCertificate) : (0, _sslHelper.upgradeToSSL)(socket, pairRecord.HostPrivateKey, pairRecord.HostCertificate);
  } catch (e) {
    usbmux.close();
    throw e;
  }
}
async function connectPort(udid, port, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));
  try {
    const device = await usbmux.findDevice(udid);
    if (!device) {
      throw new Error(`Could not find the expected device ${udid}`);
    }
    return await usbmux.connect(device.Properties.DeviceID, port, undefined);
  } catch (e) {
    usbmux.close();
    throw e;
  }
}
async function fetchImageFromGithubRepo(udid, opts) {
  const osVersion = await getOSVersion(udid);
  if (!opts.githubRepo) {
    throw new TypeError(`Mount option should contains local path or github repo, got ${JSON.stringify(opts)} instead`);
  }
  return await (0, _list_developer_image.findDeveloperImage)(osVersion, opts);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfdXNibXV4IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX3NzbEhlbHBlciIsIl9sb2Rhc2giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2xvZ2dlciIsIl9saXN0X2RldmVsb3Blcl9pbWFnZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsIm5vZGVJbnRlcm9wIiwiV2Vha01hcCIsImNhY2hlQmFiZWxJbnRlcm9wIiwiY2FjaGVOb2RlSW50ZXJvcCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiY2FjaGUiLCJoYXMiLCJnZXQiLCJuZXdPYmoiLCJoYXNQcm9wZXJ0eURlc2NyaXB0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJzZXQiLCJMT0NLRE9XTl9SRVFVRVNUIiwiREVWSUNFX1RJTUUiLCJLZXkiLCJERVZJQ0VfVVRDX09GRlNFVCIsIkRFVklDRV9USU1FX1pPTkUiLCJERVZJQ0VfVkVSU0lPTiIsIkRFVklDRV9OQU1FIiwiZ2V0Q29ubmVjdGVkRGV2aWNlcyIsInNvY2tldCIsInVzYm11eCIsIlVzYm11eCIsImdldERlZmF1bHRTb2NrZXQiLCJlIiwibG9nIiwiZGVidWciLCJkZXZpY2VzIiwibGlzdERldmljZXMiLCJ1ZGlkcyIsIm1hcCIsImRldmljZSIsIlByb3BlcnRpZXMiLCJTZXJpYWxOdW1iZXIiLCJfIiwidW5pcSIsImNsb3NlIiwiZ2V0T1NWZXJzaW9uIiwidWRpZCIsImxvY2tkb3duIiwiY29ubmVjdExvY2tkb3duIiwiZ2V0VmFsdWUiLCJnZXREZXZpY2VOYW1lIiwiZ2V0RGV2aWNlSW5mbyIsImdldERldmljZVRpbWUiLCJzdGFydExvY2tkb3duU2Vzc2lvbiIsInRpbWVzdGFtcCIsInV0Y09mZnNldCIsInRpbWVab25lIiwicGFpclJlY29yZCIsInJlYWRQYWlyUmVjb3JkIiwiRXJyb3IiLCJzdGFydFNlc3Npb24iLCJIb3N0SUQiLCJTeXN0ZW1CVUlEIiwiZW5hYmxlU2Vzc2lvblNTTCIsIkhvc3RQcml2YXRlS2V5IiwiSG9zdENlcnRpZmljYXRlIiwiY29ubmVjdFBvcnRTU0wiLCJwb3J0IiwiaGFuZHNoYWtlT25seSIsImZpbmREZXZpY2UiLCJjb25uZWN0IiwiRGV2aWNlSUQiLCJ1bmRlZmluZWQiLCJlbmFibGVTU0xIYW5kc2hha2VPbmx5IiwidXBncmFkZVRvU1NMIiwiY29ubmVjdFBvcnQiLCJmZXRjaEltYWdlRnJvbUdpdGh1YlJlcG8iLCJvcHRzIiwib3NWZXJzaW9uIiwiZ2l0aHViUmVwbyIsIlR5cGVFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJmaW5kRGV2ZWxvcGVySW1hZ2UiXSwic291cmNlcyI6WyIuLi8uLi9saWIvdXRpbGl0aWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBVc2JtdXgsIHsgZ2V0RGVmYXVsdFNvY2tldCB9IGZyb20gJy4vdXNibXV4JztcbmltcG9ydCB7IHVwZ3JhZGVUb1NTTCwgZW5hYmxlU1NMSGFuZHNoYWtlT25seSB9IGZyb20gJy4vc3NsLWhlbHBlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBmaW5kRGV2ZWxvcGVySW1hZ2UgfSBmcm9tICcuL2ltYWdlbW91bnRlci91dGlscy9saXN0X2RldmVsb3Blcl9pbWFnZSc7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW1kbWFyc2hhbGwvaU9TLUludGVybmFscy9ibG9iL21hc3Rlci9sb2NrYm90L2xvY2tib3QvbG9ja2Rvd25fa2V5cy5oXG5jb25zdCBMT0NLRE9XTl9SRVFVRVNUID0ge1xuICBERVZJQ0VfVElNRTogeyBLZXk6ICdUaW1lSW50ZXJ2YWxTaW5jZTE5NzAnIH0sXG4gIERFVklDRV9VVENfT0ZGU0VUOiB7IEtleTogJ1RpbWVab25lT2Zmc2V0RnJvbVVUQycgfSxcbiAgREVWSUNFX1RJTUVfWk9ORTogeyBLZXk6ICdUaW1lWm9uZScgfSxcbiAgREVWSUNFX1ZFUlNJT046IHsgS2V5OiAnUHJvZHVjdFZlcnNpb24nIH0sXG4gIERFVklDRV9OQU1FOiB7IEtleTogJ0RldmljZU5hbWUnIH1cbn07XG5cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHVkaWRzIG9mIHRoZSBjb25uZWN0ZWQgZGV2aWNlc1xuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCduZXQnKS5Tb2NrZXQ/fSBzb2NrZXQgdGhlIHNvY2tldCBvZiB1c2JtdXhkLiBJdCB3aWxsIGRlZmF1bHQgdG8gL3Zhci9ydW4vdXNibXV4ZCBpZiBpdCBpcyBub3QgcGFzc2VkXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IFRoZSBsaXN0IG9mIGRldmljZSBzZXJpYWwgbnVtYmVycyAodWRpZCkgb3JcbiAqIGFuIGVtcHR5IGxpc3QgaWYgbm8gZGV2aWNlcyBhcmUgY29ubmVjdGVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3RlZERldmljZXMoc29ja2V0ID0gbnVsbCkge1xuICBsZXQgdXNibXV4O1xuICB0cnkge1xuICAgIHVzYm11eCA9IG5ldyBVc2JtdXgoc29ja2V0IHx8IGF3YWl0IGdldERlZmF1bHRTb2NrZXQoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZGVidWcoZSk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IHVzYm11eC5saXN0RGV2aWNlcygpO1xuICAgIGNvbnN0IHVkaWRzID0gZGV2aWNlcy5tYXAoKGRldmljZSkgPT4gZGV2aWNlLlByb3BlcnRpZXMuU2VyaWFsTnVtYmVyKTtcbiAgICByZXR1cm4gXy51bmlxKHVkaWRzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1c2JtdXguY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgb3MgdmVyc2lvbiBvZiB0aGUgZGV2aWNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgRGV2aWNlIFVESURcbiAqIEBwYXJhbSB7aW1wb3J0KCduZXQnKS5Tb2NrZXQ/fSBzb2NrZXQgdGhlIHNvY2tldCBvZiB1c2JtdXhkLiBJdCB3aWxsIGRlZmF1bHQgdG8gL3Zhci9ydW4vdXNibXV4ZCBpZiBpdCBpcyBub3QgcGFzc2VkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRPU1ZlcnNpb24odWRpZCwgc29ja2V0ID0gbnVsbCkge1xuICBjb25zdCB1c2JtdXggPSBuZXcgVXNibXV4KHNvY2tldCB8fCBhd2FpdCBnZXREZWZhdWx0U29ja2V0KCkpO1xuICB0cnkge1xuICAgIC8vIGxvY2tkb3duIGRvZXNuJ3QgbmVlZCB0byBiZSBjbG9zZWQgc2luY2UgaXQgdXNlcyB0aGUgc2FtZSBzb2NrZXQgdXNibXV4IHVzZXNcbiAgICBjb25zdCBsb2NrZG93biA9IGF3YWl0IHVzYm11eC5jb25uZWN0TG9ja2Rvd24odWRpZCk7XG4gICAgcmV0dXJuIGF3YWl0IGxvY2tkb3duLmdldFZhbHVlKExPQ0tET1dOX1JFUVVFU1QuREVWSUNFX1ZFUlNJT04pO1xuICB9IGZpbmFsbHkge1xuICAgIHVzYm11eC5jbG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBuYW1lIG9mIHRoZSBkZXZpY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCBEZXZpY2UgVURJRFxuICogQHBhcmFtIHtpbXBvcnQoJ25ldCcpLlNvY2tldD99IHNvY2tldCB0aGUgc29ja2V0IG9mIHVzYm11eGQuIEl0IHdpbGwgZGVmYXVsdCB0byAvdmFyL3J1bi91c2JtdXhkIGlmIGl0IGlzIG5vdCBwYXNzZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldERldmljZU5hbWUodWRpZCwgc29ja2V0ID0gbnVsbCkge1xuICBjb25zdCB1c2JtdXggPSBuZXcgVXNibXV4KHNvY2tldCB8fCBhd2FpdCBnZXREZWZhdWx0U29ja2V0KCkpO1xuICB0cnkge1xuICAgIC8vIGxvY2tkb3duIGRvZXNuJ3QgbmVlZCB0byBiZSBjbG9zZWQgc2luY2UgaXQgdXNlcyB0aGUgc2FtZSBzb2NrZXQgdXNibXV4IHVzZXNcbiAgICBjb25zdCBsb2NrZG93biA9IGF3YWl0IHVzYm11eC5jb25uZWN0TG9ja2Rvd24odWRpZCk7XG4gICAgcmV0dXJuIGF3YWl0IGxvY2tkb3duLmdldFZhbHVlKExPQ0tET1dOX1JFUVVFU1QuREVWSUNFX05BTUUpO1xuICB9IGZpbmFsbHkge1xuICAgIHVzYm11eC5jbG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGRldmljZSB2YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIERldmljZSBVRElEXG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0P30gc29ja2V0IHRoZSBzb2NrZXQgb2YgdXNibXV4ZC4gSXQgd2lsbCBkZWZhdWx0IHRvIC92YXIvcnVuL3VzYm11eGQgaWYgaXQgaXMgbm90IHBhc3NlZFxuICogQHJldHVybnMge29iamVjdH0gUmV0dXJucyBhdmFpbGFibGUgZGVmYXVsdCBkZXZpY2UgdmFsdWVzIHZpYSBsb2NrZG93bi5cbiAqIGUuZy5cbiAqIHtcbiAqICAgXCJCYXNlYmFuZENlcnRJZFwiPT4zODQwMTQ5NTI4LFxuICogICBcIkJhc2ViYW5kS2V5SGFzaEluZm9ybWF0aW9uXCI9PlxuICogICAgIHtcIkFLZXlTdGF0dXNcIj0+MixcbiAqICAgICBcIlNLZXlIYXNoXCI9PntcbiAqICAgICAgIFwidHlwZVwiPT5cIkJ1ZmZlclwiLFxuICogICAgICAgXCJkYXRhXCI9PlsxODcsIDIzOSwgLi4uLl19LFxuICogICAgIFwiU0tleVN0YXR1c1wiPT4wfSxcbiAqICAgXCJCYXNlYmFuZFNlcmlhbE51bWJlclwiPT57XCJ0eXBlXCI9PlwiQnVmZmVyXCIsIFwiZGF0YVwiPT5bLi4uXX0sXG4gKiAgIFwiQmFzZWJhbmRWZXJzaW9uXCI9PlwiMTEuMDEuMDJcIixcbiAqICAgXCJCb2FyZElkXCI9PjIsXG4gKiAgIFwiQnVpbGRWZXJzaW9uXCI9PlwiMTlDNTZcIixcbiAqICAgXCJDUFVBcmNoaXRlY3R1cmVcIj0+XCJhcm02NFwiLFxuICogICBcIkNoaXBJRFwiPT4zMjc2OCxcbiAqICAgXCJEZXZpY2VDbGFzc1wiPT5cImlQaG9uZVwiLFxuICogICBcIkRldmljZUNvbG9yXCI9PlwiI2M4Y2FjYVwiLFxuICogICBcIkRldmljZU5hbWVcIj0+XCJrYXp1XCIsXG4gKiAgIFwiRGllSURcIj0+MTExMTExMTExMTExMSxcbiAqICAgXCJIYXJkd2FyZU1vZGVsXCI9PlwiTjY5dUFQXCIsXG4gKiAgIFwiSGFzU2lEUFwiPT50cnVlLFxuICogICBcIlBhcnRpdGlvblR5cGVcIj0+XCJHVUlEX3BhcnRpdGlvbl9zY2hlbWVcIixcbiAqICAgXCJQcm9kdWN0TmFtZVwiPT5cImlQaG9uZSBPU1wiLFxuICogICBcIlByb2R1Y3RUeXBlXCI9PlwiaVBob25lOCw0XCIsXG4gKiAgIFwiUHJvZHVjdFZlcnNpb25cIj0+XCIxNS4yXCIsXG4gKiAgIFwiUHJvZHVjdGlvblNPQ1wiPT50cnVlLFxuICogICBcIlByb3RvY29sVmVyc2lvblwiPT5cIjJcIixcbiAqICAgXCJTdXBwb3J0ZWREZXZpY2VGYW1pbGllc1wiPT5bMV0sXG4gKiAgIFwiVGVsZXBob255Q2FwYWJpbGl0eVwiPT50cnVlLFxuICogICBcIlVuaXF1ZUNoaXBJRFwiPT4xMTExMTExMTExMTExLFxuICogICBcIlVuaXF1ZURldmljZUlEXCI9PlwiYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYVwiLFxuICogICBcIldpRmlBZGRyZXNzXCI9PlwiMDA6MDA6MDA6MDA6MDA6MDBcIlxuICogfVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXREZXZpY2VJbmZvKHVkaWQsIHNvY2tldCA9IG51bGwpIHtcbiAgY29uc3QgdXNibXV4ID0gbmV3IFVzYm11eChzb2NrZXQgfHwgYXdhaXQgZ2V0RGVmYXVsdFNvY2tldCgpKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBsb2NrZG93biA9IGF3YWl0IHVzYm11eC5jb25uZWN0TG9ja2Rvd24odWRpZCk7XG4gICAgcmV0dXJuIGF3YWl0IGxvY2tkb3duLmdldFZhbHVlKCk7XG4gIH0gZmluYWxseSB7XG4gICAgdXNibXV4LmNsb3NlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZXZpY2VUaW1lXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVzdGFtcCBVbml4IHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIDE5NzAtMDEtMDFUMDA6MDA6MDBaXG4gKiBAcHJvcGVydHkge251bWJlcn0gdXRjT2Zmc2V0IFRoZSBkaWZmZXJlbmNlIGluIG1pbnV0ZXMgYmV0d2VlbiB0aGUgVVRDIHRpbWUgYW5kIHRoZSBsb2NhbCBkZXZpY2UgdGltZS5cbiAqIENhbiBiZSBuZWdhdGl2ZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aW1lWm9uZSBUaW1lIHpvbmUgbmFtZSBjb25maWd1cmVkIG9uIHRoZSBkZXZpY2UsIGZvciBleGFtcGxlIGBFdXJvcGUvUGFyaXNgXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGxvY2FsIHRpbWUgZnJvbSB0aGUgZGV2aWNlIHVuZGVyIHRlc3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCBEZXZpY2UgVURJRFxuICogQHBhcmFtIHtpbXBvcnQoJ25ldCcpLlNvY2tldD99IHNvY2tldCB0aGUgc29ja2V0IG9mIHVzYm11eGQuIEl0IHdpbGwgZGVmYXVsdCB0byAvdmFyL3J1bi91c2JtdXhkIGlmIGl0IGlzIG5vdCBwYXNzZWRcbiAqIEByZXR1cm5zIHtEZXZpY2VUaW1lfVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXREZXZpY2VUaW1lKHVkaWQsIHNvY2tldCA9IG51bGwpIHtcbiAgY29uc3QgbG9ja2Rvd24gPSBhd2FpdCBzdGFydExvY2tkb3duU2Vzc2lvbih1ZGlkLCBzb2NrZXQpO1xuICB0cnkge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lc3RhbXA6IGF3YWl0IGxvY2tkb3duLmdldFZhbHVlKExPQ0tET1dOX1JFUVVFU1QuREVWSUNFX1RJTUUpLFxuICAgICAgLy8gQXBwbGUgcmV0dXJucyB1dGNPZmZzZXQgaW4gc2Vjb25kcyB3aGljaCBkb2VzbnQgY29tcGx5IHdpdGggdGhlIGdlbmVyYWwgc3RhbmRhcmRcbiAgICAgIHV0Y09mZnNldDogYXdhaXQgbG9ja2Rvd24uZ2V0VmFsdWUoTE9DS0RPV05fUkVRVUVTVC5ERVZJQ0VfVVRDX09GRlNFVCkgLyA2MCxcbiAgICAgIHRpbWVab25lOiBhd2FpdCBsb2NrZG93bi5nZXRWYWx1ZShMT0NLRE9XTl9SRVFVRVNULkRFVklDRV9USU1FX1pPTkUpLFxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgbG9ja2Rvd24uY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFN0YXJ0cyBhIGxvY2tkb3duIHNlc3Npb24gb24gdGhlIGdpdmVuIGRldmljZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIERldmljZSBVRElEXG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0P30gc29ja2V0IHRoZSBzb2NrZXQgb2YgdXNibXV4ZC4gSXQgd2lsbCBkZWZhdWx0IHRvIC92YXIvcnVuL3VzYm11eGQgaWYgaXQgaXMgbm90IHBhc3NlZFxuICogQHJldHVybnMge0xvY2tkb3dufVxuICovXG5hc3luYyBmdW5jdGlvbiBzdGFydExvY2tkb3duU2Vzc2lvbih1ZGlkLCBzb2NrZXQgPSBudWxsKSB7XG4gIGNvbnN0IHVzYm11eCA9IG5ldyBVc2JtdXgoc29ja2V0IHx8IGF3YWl0IGdldERlZmF1bHRTb2NrZXQoKSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFpclJlY29yZCA9IGF3YWl0IHVzYm11eC5yZWFkUGFpclJlY29yZCh1ZGlkKTtcbiAgICBpZiAoIXBhaXJSZWNvcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBwYWlyIHJlY29yZCBmb3IgZGV2aWNlICcke3VkaWR9Jy4gUGxlYXNlIGZpcnN0IHBhaXIgd2l0aCB0aGUgZGV2aWNlYCk7XG4gICAgfVxuICAgIC8vIGxvY2tkb3duIGRvZXNuJ3QgbmVlZCB0byBiZSBjbG9zZWQgc2luY2UgaXQgdXNlcyB0aGUgc2FtZSBzb2NrZXQgdXNibXV4IHVzZXNcbiAgICBjb25zdCBsb2NrZG93biA9IGF3YWl0IHVzYm11eC5jb25uZWN0TG9ja2Rvd24odWRpZCk7XG4gICAgYXdhaXQgbG9ja2Rvd24uc3RhcnRTZXNzaW9uKHBhaXJSZWNvcmQuSG9zdElELCBwYWlyUmVjb3JkLlN5c3RlbUJVSUQpO1xuICAgIGxvY2tkb3duLmVuYWJsZVNlc3Npb25TU0wocGFpclJlY29yZC5Ib3N0UHJpdmF0ZUtleSwgcGFpclJlY29yZC5Ib3N0Q2VydGlmaWNhdGUpO1xuICAgIHJldHVybiBsb2NrZG93bjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHVzYm11eC5jbG9zZSgpO1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25uZWN0cyB0byBhIGdpdmVuIHBvcnQgd2l0aCB0aGUgY2VydHMgYW5kIGtleXMgdXNlZCBpbiB0aGUgcGFpcmluZyBwcm9jZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgRGV2aWNlIFVESURcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0IFBvcnQgdG8gY29ubmVjdFxuICogQHBhcmFtIHtpbXBvcnQoJ25ldCcpLlNvY2tldD99IHNvY2tldCB0aGUgc29ja2V0IG9mIHVzYm11eGQuIEl0IHdpbGwgZGVmYXVsdCB0byAvdmFyL3J1bi91c2JtdXhkIGlmIGl0IGlzIG5vdCBwYXNzZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFuZHNoYWtlT25seSBvbmx5IGhhbmRzaGFrZSBhbmQgcmV0dXJuIHRoZSBpbml0aWFsIHNvY2tldFxuICogQHJldHVybnMge3Rscy5UTFNTb2NrZXR8T2JqZWN0fSBUaGUgc29ja2V0IG9yIHRoZSBvYmplY3QgcmV0dXJuZWQgaW4gdGhlIGNhbGxiYWNrIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGlzdHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29ubmVjdFBvcnRTU0wodWRpZCwgcG9ydCwgc29ja2V0ID0gbnVsbCwgaGFuZHNoYWtlT25seSA9IGZhbHNlKSB7XG4gIGNvbnN0IHVzYm11eCA9IG5ldyBVc2JtdXgoc29ja2V0IHx8IGF3YWl0IGdldERlZmF1bHRTb2NrZXQoKSk7XG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdXNibXV4LmZpbmREZXZpY2UodWRpZCk7XG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIGV4cGVjdGVkIGRldmljZSAnJHt1ZGlkfSdgKTtcbiAgICB9XG4gICAgY29uc3QgcGFpclJlY29yZCA9IGF3YWl0IHVzYm11eC5yZWFkUGFpclJlY29yZCh1ZGlkKTtcbiAgICBpZiAoIXBhaXJSZWNvcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBwYWlyIHJlY29yZCBmb3IgZGV2aWNlICcke3VkaWR9Jy4gUGxlYXNlIGZpcnN0IHBhaXIgd2l0aCB0aGUgZGV2aWNlYCk7XG4gICAgfVxuICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IHVzYm11eC5jb25uZWN0KGRldmljZS5Qcm9wZXJ0aWVzLkRldmljZUlELCBwb3J0LCB1bmRlZmluZWQpO1xuICAgIHJldHVybiBoYW5kc2hha2VPbmx5ID9cbiAgICAgIGF3YWl0IGVuYWJsZVNTTEhhbmRzaGFrZU9ubHkoc29ja2V0LCBwYWlyUmVjb3JkLkhvc3RQcml2YXRlS2V5LCBwYWlyUmVjb3JkLkhvc3RDZXJ0aWZpY2F0ZSkgOlxuICAgICAgdXBncmFkZVRvU1NMKHNvY2tldCwgcGFpclJlY29yZC5Ib3N0UHJpdmF0ZUtleSwgcGFpclJlY29yZC5Ib3N0Q2VydGlmaWNhdGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXNibXV4LmNsb3NlKCk7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIENvbm5lY3RzIHRvIGEgZ2l2ZW4gcG9ydFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIERldmljZSBVRElEXG4gKiBAcGFyYW0ge251bWJlcn0gcG9ydCBQb3J0IHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7aW1wb3J0KCduZXQnKS5Tb2NrZXQ/fSBzb2NrZXQgdGhlIHNvY2tldCBvZiB1c2JtdXhkLiBJdCB3aWxsIGRlZmF1bHQgdG8gL3Zhci9ydW4vdXNibXV4ZCBpZiBpdCBpcyBub3QgcGFzc2VkXG4gKiBAcmV0dXJucyB7bmV0LlNvY2tldHxPYmplY3R9IFRoZSBzb2NrZXQgb3IgdGhlIG9iamVjdCByZXR1cm5lZCBpbiB0aGUgY2FsbGJhY2sgaWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4aXN0c1xuICovXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0UG9ydCh1ZGlkLCBwb3J0LCBzb2NrZXQgPSBudWxsKSB7XG4gIGNvbnN0IHVzYm11eCA9IG5ldyBVc2JtdXgoc29ja2V0IHx8IGF3YWl0IGdldERlZmF1bHRTb2NrZXQoKSk7XG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdXNibXV4LmZpbmREZXZpY2UodWRpZCk7XG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIGV4cGVjdGVkIGRldmljZSAke3VkaWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB1c2JtdXguY29ubmVjdChkZXZpY2UuUHJvcGVydGllcy5EZXZpY2VJRCwgcG9ydCwgdW5kZWZpbmVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHVzYm11eC5jbG9zZSgpO1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBTZWFyY2ggZGV2ZWxvcGVyIGltYWdlIGZvciBkZXZpY2UgYmFzZWQgb24gZ2l2ZW4gcmVwby4gSWYgY2VydGFpbiBmaWxlIHdhcyBmb3VuZCwgdGhpcyB3b3VsZCBhdXRvbWF0aWMgZG93bmxvYWQsXG4gKiB1bnppcCBhbmQgcmV0dXJuIHRoZSBwYXRoIG9mIGRldmVsb3BlciBpbWFnZSBhbmQgc2lnbmF0dXJlIGZpbGUuXG4gKlxuICogRGV2ZWxvcGVyIGltYWdlcyBhbmQgc2lnbmF0dXJlIGZpbGVzIHNob3VsZCBiZSBwdXQgaW50byBhIHppcCBmaWxlIHRoYXQgbWF0Y2hlcyB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbjpcbiAqIGBcXGQrXFwuXFxkKyhcXCgoW1xcd198LigpXSkrXFwpKT8uemlwYC4gVGhlIGltYWdlIGZpbGUgc2hvdWxkIGJlIG5hbWVkIHRvIGBEZXZlbG9wZXJEaXNrSW1hZ2UuZG1nYCxcbiAqICBhbmQgdGhlIHNpZ25hdHVyZSBmaWxlIHNob3VsZCBiZSBuYW1lZCB0byBgRGV2ZWxvcGVyRGlza0ltYWdlLmRtZy5zaWduYXR1cmVgLlxuICogQm90aCBmaWxlcyBzaG91bGQgYmUgcGxhY2VkIGludG8gc2FtZSBmb2xkZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW1hZ2Vtb3VudGVyL3V0aWxzL2xpc3RfZGV2ZWxvcGVyX2ltYWdlJykuSW1hZ2VGcm9tR2l0aHViUmVwb30gb3B0c1xuICogZ2l0aHViIHJlcG8gb3B0aW9uLCBgZ2l0aHViUmVwb2AgLlxuICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL2ltYWdlbW91bnRlci91dGlscy9saXN0X2RldmVsb3Blcl9pbWFnZScpLkltYWdlUGF0aD59XG4gKiBAdGhyb3dzIElmIG9wdHMgZXJyb3Igb3IgZmFpbGVkIG9uIHNlYXJjaGluZyBpbWFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaEltYWdlRnJvbUdpdGh1YlJlcG8odWRpZCwgb3B0cykge1xuICBjb25zdCBvc1ZlcnNpb24gPSBhd2FpdCBnZXRPU1ZlcnNpb24odWRpZCk7XG4gIGlmICghb3B0cy5naXRodWJSZXBvKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTW91bnQgb3B0aW9uIHNob3VsZCBjb250YWlucyBsb2NhbCBwYXRoIG9yIGdpdGh1YiByZXBvLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzKX0gaW5zdGVhZGApO1xuICB9XG4gIHJldHVybiBhd2FpdCBmaW5kRGV2ZWxvcGVySW1hZ2Uob3NWZXJzaW9uLCBvcHRzKTtcbn1cblxuXG5leHBvcnQge1xuICBnZXRDb25uZWN0ZWREZXZpY2VzLCBnZXRPU1ZlcnNpb24sIGdldERldmljZU5hbWUsIGdldERldmljZVRpbWUsXG4gIHN0YXJ0TG9ja2Rvd25TZXNzaW9uLCBjb25uZWN0UG9ydCwgY29ubmVjdFBvcnRTU0wsIGdldERldmljZUluZm8sXG4gIGZldGNoSW1hZ2VGcm9tR2l0aHViUmVwb1xufTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUFBLE9BQUEsR0FBQUMsdUJBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFDLFVBQUEsR0FBQUQsT0FBQTtBQUNBLElBQUFFLE9BQUEsR0FBQUMsc0JBQUEsQ0FBQUgsT0FBQTtBQUNBLElBQUFJLE9BQUEsR0FBQUQsc0JBQUEsQ0FBQUgsT0FBQTtBQUNBLElBQUFLLHFCQUFBLEdBQUFMLE9BQUE7QUFBK0UsU0FBQU0seUJBQUFDLFdBQUEsZUFBQUMsT0FBQSxrQ0FBQUMsaUJBQUEsT0FBQUQsT0FBQSxRQUFBRSxnQkFBQSxPQUFBRixPQUFBLFlBQUFGLHdCQUFBLFlBQUFBLENBQUFDLFdBQUEsV0FBQUEsV0FBQSxHQUFBRyxnQkFBQSxHQUFBRCxpQkFBQSxLQUFBRixXQUFBO0FBQUEsU0FBQVIsd0JBQUFZLEdBQUEsRUFBQUosV0FBQSxTQUFBQSxXQUFBLElBQUFJLEdBQUEsSUFBQUEsR0FBQSxDQUFBQyxVQUFBLFdBQUFELEdBQUEsUUFBQUEsR0FBQSxvQkFBQUEsR0FBQSx3QkFBQUEsR0FBQSw0QkFBQUUsT0FBQSxFQUFBRixHQUFBLFVBQUFHLEtBQUEsR0FBQVIsd0JBQUEsQ0FBQUMsV0FBQSxPQUFBTyxLQUFBLElBQUFBLEtBQUEsQ0FBQUMsR0FBQSxDQUFBSixHQUFBLFlBQUFHLEtBQUEsQ0FBQUUsR0FBQSxDQUFBTCxHQUFBLFNBQUFNLE1BQUEsV0FBQUMscUJBQUEsR0FBQUMsTUFBQSxDQUFBQyxjQUFBLElBQUFELE1BQUEsQ0FBQUUsd0JBQUEsV0FBQUMsR0FBQSxJQUFBWCxHQUFBLFFBQUFXLEdBQUEsa0JBQUFILE1BQUEsQ0FBQUksU0FBQSxDQUFBQyxjQUFBLENBQUFDLElBQUEsQ0FBQWQsR0FBQSxFQUFBVyxHQUFBLFNBQUFJLElBQUEsR0FBQVIscUJBQUEsR0FBQUMsTUFBQSxDQUFBRSx3QkFBQSxDQUFBVixHQUFBLEVBQUFXLEdBQUEsY0FBQUksSUFBQSxLQUFBQSxJQUFBLENBQUFWLEdBQUEsSUFBQVUsSUFBQSxDQUFBQyxHQUFBLEtBQUFSLE1BQUEsQ0FBQUMsY0FBQSxDQUFBSCxNQUFBLEVBQUFLLEdBQUEsRUFBQUksSUFBQSxZQUFBVCxNQUFBLENBQUFLLEdBQUEsSUFBQVgsR0FBQSxDQUFBVyxHQUFBLFNBQUFMLE1BQUEsQ0FBQUosT0FBQSxHQUFBRixHQUFBLE1BQUFHLEtBQUEsSUFBQUEsS0FBQSxDQUFBYSxHQUFBLENBQUFoQixHQUFBLEVBQUFNLE1BQUEsWUFBQUEsTUFBQTtBQUcvRSxNQUFNVyxnQkFBZ0IsR0FBRztFQUN2QkMsV0FBVyxFQUFFO0lBQUVDLEdBQUcsRUFBRTtFQUF3QixDQUFDO0VBQzdDQyxpQkFBaUIsRUFBRTtJQUFFRCxHQUFHLEVBQUU7RUFBd0IsQ0FBQztFQUNuREUsZ0JBQWdCLEVBQUU7SUFBRUYsR0FBRyxFQUFFO0VBQVcsQ0FBQztFQUNyQ0csY0FBYyxFQUFFO0lBQUVILEdBQUcsRUFBRTtFQUFpQixDQUFDO0VBQ3pDSSxXQUFXLEVBQUU7SUFBRUosR0FBRyxFQUFFO0VBQWE7QUFDbkMsQ0FBQztBQVVELGVBQWVLLG1CQUFtQkEsQ0FBQ0MsTUFBTSxHQUFHLElBQUksRUFBRTtFQUNoRCxJQUFJQyxNQUFNO0VBQ1YsSUFBSTtJQUNGQSxNQUFNLEdBQUcsSUFBSUMsZUFBTSxDQUFDRixNQUFNLEtBQUksTUFBTSxJQUFBRyx3QkFBZ0IsRUFBQyxDQUFDLEVBQUM7RUFDekQsQ0FBQyxDQUFDLE9BQU9DLENBQUMsRUFBRTtJQUNWQyxlQUFHLENBQUNDLEtBQUssQ0FBQ0YsQ0FBQyxDQUFDO0lBQ1osT0FBTyxFQUFFO0VBQ1g7RUFDQSxJQUFJO0lBQ0YsTUFBTUcsT0FBTyxHQUFHLE1BQU1OLE1BQU0sQ0FBQ08sV0FBVyxDQUFDLENBQUM7SUFDMUMsTUFBTUMsS0FBSyxHQUFHRixPQUFPLENBQUNHLEdBQUcsQ0FBRUMsTUFBTSxJQUFLQSxNQUFNLENBQUNDLFVBQVUsQ0FBQ0MsWUFBWSxDQUFDO0lBQ3JFLE9BQU9DLGVBQUMsQ0FBQ0MsSUFBSSxDQUFDTixLQUFLLENBQUM7RUFDdEIsQ0FBQyxTQUFTO0lBQ1JSLE1BQU0sQ0FBQ2UsS0FBSyxDQUFDLENBQUM7RUFDaEI7QUFDRjtBQVNBLGVBQWVDLFlBQVlBLENBQUNDLElBQUksRUFBRWxCLE1BQU0sR0FBRyxJQUFJLEVBQUU7RUFDL0MsTUFBTUMsTUFBTSxHQUFHLElBQUlDLGVBQU0sQ0FBQ0YsTUFBTSxLQUFJLE1BQU0sSUFBQUcsd0JBQWdCLEVBQUMsQ0FBQyxFQUFDO0VBQzdELElBQUk7SUFFRixNQUFNZ0IsUUFBUSxHQUFHLE1BQU1sQixNQUFNLENBQUNtQixlQUFlLENBQUNGLElBQUksQ0FBQztJQUNuRCxPQUFPLE1BQU1DLFFBQVEsQ0FBQ0UsUUFBUSxDQUFDN0IsZ0JBQWdCLENBQUNLLGNBQWMsQ0FBQztFQUNqRSxDQUFDLFNBQVM7SUFDUkksTUFBTSxDQUFDZSxLQUFLLENBQUMsQ0FBQztFQUNoQjtBQUNGO0FBU0EsZUFBZU0sYUFBYUEsQ0FBQ0osSUFBSSxFQUFFbEIsTUFBTSxHQUFHLElBQUksRUFBRTtFQUNoRCxNQUFNQyxNQUFNLEdBQUcsSUFBSUMsZUFBTSxDQUFDRixNQUFNLEtBQUksTUFBTSxJQUFBRyx3QkFBZ0IsRUFBQyxDQUFDLEVBQUM7RUFDN0QsSUFBSTtJQUVGLE1BQU1nQixRQUFRLEdBQUcsTUFBTWxCLE1BQU0sQ0FBQ21CLGVBQWUsQ0FBQ0YsSUFBSSxDQUFDO0lBQ25ELE9BQU8sTUFBTUMsUUFBUSxDQUFDRSxRQUFRLENBQUM3QixnQkFBZ0IsQ0FBQ00sV0FBVyxDQUFDO0VBQzlELENBQUMsU0FBUztJQUNSRyxNQUFNLENBQUNlLEtBQUssQ0FBQyxDQUFDO0VBQ2hCO0FBQ0Y7QUF5Q0EsZUFBZU8sYUFBYUEsQ0FBQ0wsSUFBSSxFQUFFbEIsTUFBTSxHQUFHLElBQUksRUFBRTtFQUNoRCxNQUFNQyxNQUFNLEdBQUcsSUFBSUMsZUFBTSxDQUFDRixNQUFNLEtBQUksTUFBTSxJQUFBRyx3QkFBZ0IsRUFBQyxDQUFDLEVBQUM7RUFDN0QsSUFBSTtJQUNGLE1BQU1nQixRQUFRLEdBQUcsTUFBTWxCLE1BQU0sQ0FBQ21CLGVBQWUsQ0FBQ0YsSUFBSSxDQUFDO0lBQ25ELE9BQU8sTUFBTUMsUUFBUSxDQUFDRSxRQUFRLENBQUMsQ0FBQztFQUNsQyxDQUFDLFNBQVM7SUFDUnBCLE1BQU0sQ0FBQ2UsS0FBSyxDQUFDLENBQUM7RUFDaEI7QUFDRjtBQWtCQSxlQUFlUSxhQUFhQSxDQUFDTixJQUFJLEVBQUVsQixNQUFNLEdBQUcsSUFBSSxFQUFFO0VBQ2hELE1BQU1tQixRQUFRLEdBQUcsTUFBTU0sb0JBQW9CLENBQUNQLElBQUksRUFBRWxCLE1BQU0sQ0FBQztFQUN6RCxJQUFJO0lBQ0YsT0FBTztNQUNMMEIsU0FBUyxFQUFFLE1BQU1QLFFBQVEsQ0FBQ0UsUUFBUSxDQUFDN0IsZ0JBQWdCLENBQUNDLFdBQVcsQ0FBQztNQUVoRWtDLFNBQVMsRUFBRSxPQUFNUixRQUFRLENBQUNFLFFBQVEsQ0FBQzdCLGdCQUFnQixDQUFDRyxpQkFBaUIsQ0FBQyxJQUFHLEVBQUU7TUFDM0VpQyxRQUFRLEVBQUUsTUFBTVQsUUFBUSxDQUFDRSxRQUFRLENBQUM3QixnQkFBZ0IsQ0FBQ0ksZ0JBQWdCO0lBQ3JFLENBQUM7RUFDSCxDQUFDLFNBQVM7SUFDUnVCLFFBQVEsQ0FBQ0gsS0FBSyxDQUFDLENBQUM7RUFDbEI7QUFDRjtBQVNBLGVBQWVTLG9CQUFvQkEsQ0FBQ1AsSUFBSSxFQUFFbEIsTUFBTSxHQUFHLElBQUksRUFBRTtFQUN2RCxNQUFNQyxNQUFNLEdBQUcsSUFBSUMsZUFBTSxDQUFDRixNQUFNLEtBQUksTUFBTSxJQUFBRyx3QkFBZ0IsRUFBQyxDQUFDLEVBQUM7RUFDN0QsSUFBSTtJQUNGLE1BQU0wQixVQUFVLEdBQUcsTUFBTTVCLE1BQU0sQ0FBQzZCLGNBQWMsQ0FBQ1osSUFBSSxDQUFDO0lBQ3BELElBQUksQ0FBQ1csVUFBVSxFQUFFO01BQ2YsTUFBTSxJQUFJRSxLQUFLLENBQUUsNENBQTJDYixJQUFLLHNDQUFxQyxDQUFDO0lBQ3pHO0lBRUEsTUFBTUMsUUFBUSxHQUFHLE1BQU1sQixNQUFNLENBQUNtQixlQUFlLENBQUNGLElBQUksQ0FBQztJQUNuRCxNQUFNQyxRQUFRLENBQUNhLFlBQVksQ0FBQ0gsVUFBVSxDQUFDSSxNQUFNLEVBQUVKLFVBQVUsQ0FBQ0ssVUFBVSxDQUFDO0lBQ3JFZixRQUFRLENBQUNnQixnQkFBZ0IsQ0FBQ04sVUFBVSxDQUFDTyxjQUFjLEVBQUVQLFVBQVUsQ0FBQ1EsZUFBZSxDQUFDO0lBQ2hGLE9BQU9sQixRQUFRO0VBQ2pCLENBQUMsQ0FBQyxPQUFPZixDQUFDLEVBQUU7SUFDVkgsTUFBTSxDQUFDZSxLQUFLLENBQUMsQ0FBQztJQUNkLE1BQU1aLENBQUM7RUFDVDtBQUNGO0FBV0EsZUFBZWtDLGNBQWNBLENBQUNwQixJQUFJLEVBQUVxQixJQUFJLEVBQUV2QyxNQUFNLEdBQUcsSUFBSSxFQUFFd0MsYUFBYSxHQUFHLEtBQUssRUFBRTtFQUM5RSxNQUFNdkMsTUFBTSxHQUFHLElBQUlDLGVBQU0sQ0FBQ0YsTUFBTSxLQUFJLE1BQU0sSUFBQUcsd0JBQWdCLEVBQUMsQ0FBQyxFQUFDO0VBQzdELElBQUk7SUFDRixNQUFNUSxNQUFNLEdBQUcsTUFBTVYsTUFBTSxDQUFDd0MsVUFBVSxDQUFDdkIsSUFBSSxDQUFDO0lBQzVDLElBQUksQ0FBQ1AsTUFBTSxFQUFFO01BQ1gsTUFBTSxJQUFJb0IsS0FBSyxDQUFFLHVDQUFzQ2IsSUFBSyxHQUFFLENBQUM7SUFDakU7SUFDQSxNQUFNVyxVQUFVLEdBQUcsTUFBTTVCLE1BQU0sQ0FBQzZCLGNBQWMsQ0FBQ1osSUFBSSxDQUFDO0lBQ3BELElBQUksQ0FBQ1csVUFBVSxFQUFFO01BQ2YsTUFBTSxJQUFJRSxLQUFLLENBQUUsNENBQTJDYixJQUFLLHNDQUFxQyxDQUFDO0lBQ3pHO0lBQ0EsTUFBTWxCLE1BQU0sR0FBRyxNQUFNQyxNQUFNLENBQUN5QyxPQUFPLENBQUMvQixNQUFNLENBQUNDLFVBQVUsQ0FBQytCLFFBQVEsRUFBRUosSUFBSSxFQUFFSyxTQUFTLENBQUM7SUFDaEYsT0FBT0osYUFBYSxHQUNsQixNQUFNLElBQUFLLGlDQUFzQixFQUFDN0MsTUFBTSxFQUFFNkIsVUFBVSxDQUFDTyxjQUFjLEVBQUVQLFVBQVUsQ0FBQ1EsZUFBZSxDQUFDLEdBQzNGLElBQUFTLHVCQUFZLEVBQUM5QyxNQUFNLEVBQUU2QixVQUFVLENBQUNPLGNBQWMsRUFBRVAsVUFBVSxDQUFDUSxlQUFlLENBQUM7RUFDL0UsQ0FBQyxDQUFDLE9BQU9qQyxDQUFDLEVBQUU7SUFDVkgsTUFBTSxDQUFDZSxLQUFLLENBQUMsQ0FBQztJQUNkLE1BQU1aLENBQUM7RUFDVDtBQUNGO0FBVUEsZUFBZTJDLFdBQVdBLENBQUM3QixJQUFJLEVBQUVxQixJQUFJLEVBQUV2QyxNQUFNLEdBQUcsSUFBSSxFQUFFO0VBQ3BELE1BQU1DLE1BQU0sR0FBRyxJQUFJQyxlQUFNLENBQUNGLE1BQU0sS0FBSSxNQUFNLElBQUFHLHdCQUFnQixFQUFDLENBQUMsRUFBQztFQUM3RCxJQUFJO0lBQ0YsTUFBTVEsTUFBTSxHQUFHLE1BQU1WLE1BQU0sQ0FBQ3dDLFVBQVUsQ0FBQ3ZCLElBQUksQ0FBQztJQUM1QyxJQUFJLENBQUNQLE1BQU0sRUFBRTtNQUNYLE1BQU0sSUFBSW9CLEtBQUssQ0FBRSxzQ0FBcUNiLElBQUssRUFBQyxDQUFDO0lBQy9EO0lBQ0EsT0FBTyxNQUFNakIsTUFBTSxDQUFDeUMsT0FBTyxDQUFDL0IsTUFBTSxDQUFDQyxVQUFVLENBQUMrQixRQUFRLEVBQUVKLElBQUksRUFBRUssU0FBUyxDQUFDO0VBQzFFLENBQUMsQ0FBQyxPQUFPeEMsQ0FBQyxFQUFFO0lBQ1ZILE1BQU0sQ0FBQ2UsS0FBSyxDQUFDLENBQUM7SUFDZCxNQUFNWixDQUFDO0VBQ1Q7QUFDRjtBQWdCQSxlQUFlNEMsd0JBQXdCQSxDQUFDOUIsSUFBSSxFQUFFK0IsSUFBSSxFQUFFO0VBQ2xELE1BQU1DLFNBQVMsR0FBRyxNQUFNakMsWUFBWSxDQUFDQyxJQUFJLENBQUM7RUFDMUMsSUFBSSxDQUFDK0IsSUFBSSxDQUFDRSxVQUFVLEVBQUU7SUFDcEIsTUFBTSxJQUFJQyxTQUFTLENBQUUsK0RBQThEQyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0wsSUFBSSxDQUFFLFVBQVMsQ0FBQztFQUNwSDtFQUNBLE9BQU8sTUFBTSxJQUFBTSx3Q0FBa0IsRUFBQ0wsU0FBUyxFQUFFRCxJQUFJLENBQUM7QUFDbEQifQ==